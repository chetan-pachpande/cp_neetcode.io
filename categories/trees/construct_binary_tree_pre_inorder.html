<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode 105: Construct Binary Tree from Preorder and Inorder Traversal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border: 1px solid #e5e7eb;
        }
        .control-btn {
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #d1d5db;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            transition: all 0.2s;
            color: #374151;
        }
        .control-btn:hover {
            background-color: #f9fafb;
            border-color: #9ca3af;
        }
        .control-btn:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
        }
        .log-container {
            height: 150px;
            background-color: #111827;
            color: #d1d5db;
            font-family: monospace;
            font-size: 0.875rem;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-y: auto;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
        }
        .vis-array-element {
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #ccc;
            background-color: #f9fafb;
            font-weight: 600;
            margin: 2px;
        }
        .vis-array-element.highlight-pre {
            background-color: #fef9c3;
            border-color: #f59e0b;
            border-width: 2px;
        }
        .vis-array-element.highlight-in-range {
            background-color: #dbeafe;
            border-color: #60a5fa;
        }
        .vis-array-element.highlight-in-root {
            background-color: #bbf7d0;
            border-color: #4ade80;
            border-width: 2px;
        }
        .tree-node circle {
            fill: white;
            stroke: #333;
            stroke-width: 2;
        }
        .tree-node text {
            text-anchor: middle;
            font-size: 14px;
            font-weight: bold;
        }
        .tree-edge {
            stroke: #666;
            stroke-width: 2;
        }
        .mermaid svg { width: 100%; height: 100%; }
        .mermaid .node.active > rect {
            fill: #fef9c3 !important;
            stroke: #f59e0b !important;
            stroke-width: 2px !important;
        }
        .stack-frame {
            background-color: #eef2ff;
            border: 1px solid #c7d2fe;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            margin-top: 0.5rem;
        }
        .stack-frame.top {
            background-color: #c7d2fe;
            font-weight: bold;
        }
        .call-stack-item {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }
        .call-stack-item.active {
            background-color: #dbeafe;
            border-color: #60a5fa;
            font-weight: bold;
        }
        .code-step {
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .code-step-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }
        .code-step-number {
            flex-shrink: 0;
            width: 2rem;
            height: 2rem;
            background-color: #3b82f6;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
        }
        .log-entry {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
        }
        .log-info {
            color: #3b82f6;
        }
        .log-success {
            color: #10b981;
        }
        .log-warning {
            color: #f59e0b;
        }
        .log-error {
            color: #ef4444;
        }
        .state-value {
            font-weight: bold;
            color: #1f2937;
        }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="bg-gradient-to-r from-blue-600 to-blue-700 text-white p-8 rounded-lg mb-8 text-center">
            <h1 class="text-4xl font-bold text-white">LeetCode 105: Construct Binary Tree from Preorder and Inorder Traversal</h1>
            <p class="text-lg text-blue-100 mt-2">An Interactive Visual Explainer</p>
            <p class="text-sm text-blue-200 mt-1">Idea By: Chetan Pachpande | Executed By: Gemini</p>
        </header>
        <div class="mb-6">
            <a href="../../index.html" class="inline-block bg-gray-800 text-white px-4 py-2 rounded hover:bg-gray-900 transition">Back to Home</a>
        </div>

        <div id="problem-card" class="card">
            <h2 class="text-2xl font-bold mb-4">Problem Description</h2>
            <div class="space-y-4 text-gray-700">
                <p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return the binary tree.</p>
                <div class="bg-gray-100 p-4 rounded-lg text-sm">
                    <p><strong>Example 1:</strong></p>
                    <p><strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</p>
                    <p><strong>Output:</strong> [3,9,20,null,null,15,7]</p>
                    <p><strong>Explanation:</strong> The binary tree is constructed as follows:</p>
                    <pre class="mt-2 text-xs">     3
   /   \
  9     20
       /  \
      15   7</pre>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-2">Complexity Analysis</h3>
                    <p><strong>Time Complexity:</strong> <code>O(N)</code><br><span class="text-sm text-gray-600">We visit each node once. The HashMap lookup for the inorder index is O(1).</span></p>
                    <p class="mt-2"><strong>Space Complexity:</strong> <code>O(N)</code><br><span class="text-sm text-gray-600">O(N) for the HashMap and O(H) for the recursion stack, where H is the height of the tree. In the worst case (a skewed tree), H can be N.</span></p>
                </div>
                <div class="mt-6">
                    <h3 class="text-xl font-semibold mb-2">Java Solution</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg text-sm overflow-x-auto"><code>class Solution {
    private int preorderIndex = 0;
    private HashMap&lt;Integer, Integer&gt; inorderMap;
    
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // Build HashMap for O(1) inorder index lookup
        inorderMap = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        
        return buildTreeHelper(preorder, 0, inorder.length - 1);
    }
    
    private TreeNode buildTreeHelper(int[] preorder, int left, int right) {
        if (left &gt; right) {
            return null;  // Base case: empty subtree
        }
        
        // Get root value from preorder
        int rootVal = preorder[preorderIndex++];
        TreeNode root = new TreeNode(rootVal);
        
        // Find root position in inorder
        int rootIndex = inorderMap.get(rootVal);
        
        // Build left and right subtrees
        root.left = buildTreeHelper(preorder, left, rootIndex - 1);
        root.right = buildTreeHelper(preorder, rootIndex + 1, right);
        
        return root;
    }
}</code></pre>
                </div>
            </div>
        </div>

        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8 mt-8">

            <!-- Left Column -->
            <div class="lg:col-span-2">
                <div id="intuition-card" class="card">
                    <h2 class="text-2xl font-bold mb-4">Intuition</h2>
                    <p class="mb-3">This problem leverages the unique properties of **preorder** and **inorder** traversals to reconstruct a binary tree.</p>
                    <ol class="list-decimal list-inside space-y-2">
                        <li><strong>Preorder Logic:</strong> The first element is always the root of the current subtree.</li>
                        <li><strong>Inorder Split:</strong> Find the root in inorder traversal to determine left and right subtree boundaries.</li>
                        <li><strong>Recursive Construction:</strong> Use these boundaries to recursively build left and right subtrees.</li>
                        <li><strong>HashMap Optimization:</strong> Store inorder indices in a HashMap for O(1) lookups instead of O(N) searches.</li>
                    </ol>
                </div>

                <div id="code-steps-card" class="card">
                    <h2 class="text-2xl font-bold mb-4">Step-by-Step Code</h2>
                    <div id="code-steps-container"></div>
                    <div class="flex justify-between mt-6">
                        <button id="prev-step-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg transition-colors">Previous</button>
                        <button id="next-step-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Next</button>
                    </div>
                </div>
            </div>

            <!-- Right Column -->
            <div class="lg:col-span-3">
                <div id="visualization-card" class="card">
                    <h2 class="text-2xl font-bold mb-4">Live Visualization</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="preorder-input" class="block text-sm font-medium text-gray-700">Preorder Array</label>
                            <input type="text" id="preorder-input" value="3,9,20,15,7" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                        </div>
                        <div>
                            <label for="inorder-input" class="block text-sm font-medium text-gray-700">Inorder Array</label>
                            <input type="text" id="inorder-input" value="9,3,15,20,7" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm">
                            <button id="run-btn" class="mt-2 w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Run Visualization</button>
                        </div>
                    </div>

                    <!-- Array Visualizations -->
                    <div class="space-y-4 mb-4">
                        <div>
                            <h3 class="font-semibold mb-2">Preorder Array:</h3>
                            <div id="preorder-vis" class="flex flex-wrap gap-1"></div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Inorder Array:</h3>
                            <div id="inorder-vis" class="flex flex-wrap gap-1"></div>
                        </div>
                    </div>

                    <!-- Tree Visualization -->
                    <div id="visualization-panel" class="relative bg-gray-100 p-4 rounded-lg min-h-[300px] flex items-center justify-center">
                        <svg id="tree-svg" class="w-full h-full" width="600" height="400"></svg>
                    </div>
                </div>
                
                <div id="algorithm-states-card" class="card">
                    <h2 class="text-2xl font-bold mb-4">Algorithm States</h2>
                    <div class="space-y-3 text-base">
                        <div class="grid grid-cols-2 gap-x-4">
                            <span>Status:</span> <span id="state-status" class="state-value">Idle</span>
                            <span>Preorder Index:</span> <span id="state-preorder-index" class="state-value">N/A</span>
                            <span>Current Range:</span> <span id="state-range" class="state-value">N/A</span>
                            <span>Root Value:</span> <span id="state-root-value" class="state-value">N/A</span>
                            <span>Root Inorder Index:</span> <span id="state-root-index" class="state-value">N/A</span>
                        </div>
                    </div>
                </div>
                
                <div id="call-stack-card" class="card">
                    <h2 class="text-2xl font-bold mb-4">Call Stack</h2>
                    <div id="call-stack-container" class="space-y-2 h-40 overflow-y-auto bg-gray-50 p-2 rounded-lg">
                        <p class="text-gray-500 text-center">Stack is empty</p>
                    </div>
                </div>

                <div id="execution-commands-card" class="card">
                     <h2 class="text-2xl font-bold mb-4 text-center">Execution Commands</h2>
                    <div class="flex items-center justify-center space-x-4">
                        <button id="step-back-btn" class="control-btn" title="Step Backward">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7" /></svg>
                        </button>
                        <button id="play-pause-btn" class="control-btn w-16 h-16 bg-blue-500 text-white hover:bg-blue-600" title="Play/Pause">
                            <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                            <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 hidden" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" /></svg>
                        </button>
                        <button id="step-forward-btn" class="control-btn" title="Step Forward">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7" /></svg>
                        </button>
                        <button id="reset-btn" class="control-btn" title="Reset">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                        </button>
                    </div>
                </div>
            </div>
        </main>

        <footer class="mt-8">
            <div id="log-card" class="card">
                <h2 class="text-2xl font-bold mb-4">Execution Log</h2>
                <div id="log-container" class="log-container">
                    <div class="text-gray-500">Execution log will appear here...</div>
                </div>
            </div>
        </footer>
    </div>

    <script>
        console.log('Script loaded successfully');
        
        // Global variables
        let preorderArray = [];
        let inorderArray = [];
        let steps = [];
        let currentStep = 0;
        let isPlaying = false;
        let playInterval = null;
        let callStack = [];
        let currentCodeStep = 0;
        
        // Algorithm steps
        const algorithmSteps = [
            {
                title: "Initialize",
                description: "Create a HashMap for O(1) inorder index lookup and start the recursive process.",
                code: `HashMap<Integer, Integer> inorderMap = new HashMap<>();
for (int i = 0; i < inorder.length; i++) {
    inorderMap.put(inorder[i], i);
}
return buildTreeHelper(preorder, 0, inorder.length - 1);`
            },
            {
                title: "Base Case Check",
                description: "If left > right, we have an empty subtree, so return null.",
                code: `private TreeNode buildTreeHelper(int[] preorder, int left, int right) {
    if (left > right) {
        return null;  // Base case: empty subtree
    }`
            },
            {
                title: "Get Root Value",
                description: "The current root is always the next element in preorder traversal.",
                code: `int rootVal = preorder[preorderIndex++];
TreeNode root = new TreeNode(rootVal);`
            },
            {
                title: "Find Root in Inorder",
                description: "Find the root's position in inorder to split into left and right subtrees.",
                code: `int rootIndex = inorderMap.get(rootVal);
// rootIndex splits inorder into left and right parts`
            },
            {
                title: "Build Left Subtree",
                description: "Recursively build the left subtree with elements before root in inorder.",
                code: `root.left = buildTreeHelper(preorder, left, rootIndex - 1);`
            },
            {
                title: "Build Right Subtree", 
                description: "Recursively build the right subtree with elements after root in inorder.",
                code: `root.right = buildTreeHelper(preorder, rootIndex + 1, right);`
            },
            {
                title: "Return Node",
                description: "Return the constructed node with its left and right children.",
                code: `return root;  // Return the complete subtree`
            }
        ];
        
        // DOM elements
        const preorderInput = document.getElementById('preorder-input');
        const inorderInput = document.getElementById('inorder-input');
        const runBtn = document.getElementById('run-btn');
        const preorderVis = document.getElementById('preorder-vis');
        const inorderVis = document.getElementById('inorder-vis');
        const treeSvg = document.getElementById('tree-svg');
        const logContainer = document.getElementById('log-container');
        const stepBackBtn = document.getElementById('step-back-btn');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stepForwardBtn = document.getElementById('step-forward-btn');
        const resetBtn = document.getElementById('reset-btn');
        const codeStepsContainer = document.getElementById('code-steps-container');
        const callStackContainer = document.getElementById('call-stack-container');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        
        function logWithType(message, type = 'info') {
            console.log(message);
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function log(message) {
            logWithType(message, 'info');
        }
        
        function displayCodeStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= algorithmSteps.length) return;
            
            currentCodeStep = stepIndex;
            const step = algorithmSteps[stepIndex];
            
            codeStepsContainer.innerHTML = `
                <div class="code-step">
                    <div class="code-step-header">
                        <div class="code-step-number">${stepIndex + 1}</div>
                        <div>
                            <div class="font-bold">Step ${stepIndex + 1}: ${step.title}</div>
                            <div class="text-sm text-gray-600 mt-1">${step.description}</div>
                        </div>
                    </div>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg text-sm overflow-x-auto mt-3"><code>${step.code}</code></pre>
                </div>
            `;
            
            prevStepBtn.disabled = currentCodeStep === 0;
            nextStepBtn.disabled = currentCodeStep === algorithmSteps.length - 1;
        }
        
        function updateCallStack(stack) {
            if (stack.length === 0) {
                callStackContainer.innerHTML = '<div class="text-gray-500 text-center py-4">Stack is empty</div>';
                return;
            }
            
            callStackContainer.innerHTML = stack.map((call, index) => 
                `<div class="call-stack-item ${index === stack.length - 1 ? 'active' : ''}">
                    buildTreeHelper(left=${call.left}, right=${call.right}) → ${call.description}
                </div>`
            ).reverse().join('');
        }
        
        function updateFlowchart(currentFlow) {
            // Reset all flowchart nodes
            document.querySelectorAll('.flowchart-node').forEach(node => {
                node.classList.remove('active');
            });
            
            // Highlight current step
            if (currentFlow) {
                const node = document.getElementById(`flow-${currentFlow}`);
                if (node) node.classList.add('active');
            }
        }
        
        function displayArrays(preIndex = -1, inLeft = -1, inRight = -1, inMid = -1) {
            // Display preorder array
            preorderVis.innerHTML = preorderArray.map((val, i) => {
                let classes = 'vis-array-element';
                if (i === preIndex) classes += ' highlight-pre';
                return `<div class="${classes}">${val}</div>`;
            }).join('');
            
            // Display inorder array
            inorderVis.innerHTML = inorderArray.map((val, i) => {
                let classes = 'vis-array-element';
                if (i >= inLeft && i <= inRight && inLeft >= 0 && inRight >= 0) {
                    classes += ' highlight-in-range';
                }
                if (i === inMid) classes += ' highlight-in-root';
                return `<div class="${classes}">${val}</div>`;
            }).join('');
        }
        
        function drawTree(treeData) {
            treeSvg.innerHTML = '';
            if (!treeData || treeData.length === 0) return;
            
            const width = 600;
            const height = 400;
            const nodeRadius = 25;
            
            // Position nodes
            const positions = new Map();
            
            function calculatePositions(nodeId, level, position, levelWidth) {
                const x = (position + 0.5) * (width / levelWidth);
                const y = 60 + level * 90; // Increased spacing
                positions.set(nodeId, { x, y });
                
                const node = treeData.find(n => n.id === nodeId);
                if (node) {
                    let childPos = position * 2;
                    if (node.left) calculatePositions(node.left, level + 1, childPos, levelWidth * 2);
                    if (node.right) calculatePositions(node.right, level + 1, childPos + 1, levelWidth * 2);
                }
            }
            
            if (treeData.length > 0) {
                calculatePositions(treeData[0].id, 0, 0, 1);
            }
            
            // Draw edges
            treeData.forEach(node => {
                const nodePos = positions.get(node.id);
                if (node.left) {
                    const leftPos = positions.get(node.left);
                    if (leftPos) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', nodePos.x);
                        line.setAttribute('y1', nodePos.y);
                        line.setAttribute('x2', leftPos.x);
                        line.setAttribute('y2', leftPos.y);
                        line.setAttribute('class', 'tree-edge');
                        treeSvg.appendChild(line);
                    }
                }
                if (node.right) {
                    const rightPos = positions.get(node.right);
                    if (rightPos) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', nodePos.x);
                        line.setAttribute('y1', nodePos.y);
                        line.setAttribute('x2', rightPos.x);
                        line.setAttribute('y2', rightPos.y);
                        line.setAttribute('class', 'tree-edge');
                        treeSvg.appendChild(line);
                    }
                }
            });
            
            // Draw nodes
            treeData.forEach(node => {
                const pos = positions.get(node.id);
                if (pos) {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'tree-node');
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', pos.x);
                    circle.setAttribute('cy', pos.y);
                    circle.setAttribute('r', nodeRadius);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', pos.x);
                    text.setAttribute('y', pos.y + 5);
                    text.textContent = node.val;
                    
                    g.appendChild(circle);
                    g.appendChild(text);
                    treeSvg.appendChild(g);
                }
            });
        }
        
        function buildTree() {
            steps = [];
            callStack = [];
            
            const inorderMap = new Map();
            for (let i = 0; i < inorderArray.length; i++) {
                inorderMap.set(inorderArray[i], i);
            }
            
            let preIndex = 0;
            let nodeCounter = 0;
            const allNodes = [];
            
            function dfs(left, right, depth = 0) {
                // Add to call stack
                const currentCall = { left, right, description: `Processing range [${left}, ${right}]`, depth };
                callStack.push(currentCall);
                
                steps.push({
                    preIndex,
                    inLeft: left,
                    inRight: right,
                    inMid: -1,
                    message: `🔄 Calling buildTreeHelper(left=${left}, right=${right})`,
                    treeData: JSON.parse(JSON.stringify(allNodes)),
                    callStack: JSON.parse(JSON.stringify(callStack)),
                    codeStep: 1,
                    flowStep: 'start'
                });
                
                if (left > right) {
                    callStack.pop(); // Remove from stack
                    steps.push({
                        preIndex,
                        inLeft: left,
                        inRight: right,
                        inMid: -1,
                        message: `❌ Base case: left > right, return null`,
                        treeData: JSON.parse(JSON.stringify(allNodes)),
                        callStack: JSON.parse(JSON.stringify(callStack)),
                        codeStep: 1,
                        flowStep: 'check'
                    });
                    return null;
                }
                
                const rootVal = preorderArray[preIndex];
                const rootId = `node_${nodeCounter++}`;
                const rootInorderIndex = inorderMap.get(rootVal);
                
                preIndex++;
                
                steps.push({
                    preIndex,
                    inLeft: left,
                    inRight: right,
                    inMid: -1,
                    message: `🎯 Getting root value ${rootVal} from preorder[${preIndex-1}]`,
                    treeData: JSON.parse(JSON.stringify(allNodes)),
                    callStack: JSON.parse(JSON.stringify(callStack)),
                    codeStep: 2,
                    flowStep: 'root'
                });
                
                const node = {
                    id: rootId,
                    val: rootVal,
                    left: null,
                    right: null
                };
                allNodes.push(node);
                
                steps.push({
                    preIndex,
                    inLeft: left,
                    inRight: right,
                    inMid: rootInorderIndex,
                    message: `📍 Found ${rootVal} at inorder index ${rootInorderIndex}`,
                    treeData: JSON.parse(JSON.stringify(allNodes)),
                    callStack: JSON.parse(JSON.stringify(callStack)),
                    codeStep: 3,
                    flowStep: 'find'
                });
                
                // Build left subtree
                steps.push({
                    preIndex,
                    inLeft: left,
                    inRight: right,
                    inMid: rootInorderIndex,
                    message: `⬅️ Building left subtree for range [${left}, ${rootInorderIndex - 1}]`,
                    treeData: JSON.parse(JSON.stringify(allNodes)),
                    callStack: JSON.parse(JSON.stringify(callStack)),
                    codeStep: 4,
                    flowStep: 'left'
                });
                
                const leftChild = dfs(left, rootInorderIndex - 1, depth + 1);
                if (leftChild) {
                    node.left = leftChild.id;
                    steps.push({
                        preIndex,
                        inLeft: left,
                        inRight: right,
                        inMid: rootInorderIndex,
                        message: `✅ Connected ${rootVal}.left → ${leftChild.val}`,
                        treeData: JSON.parse(JSON.stringify(allNodes)),
                        callStack: JSON.parse(JSON.stringify(callStack)),
                        codeStep: 4,
                        flowStep: 'left'
                    });
                }
                
                // Build right subtree
                steps.push({
                    preIndex,
                    inLeft: left,
                    inRight: right,
                    inMid: rootInorderIndex,
                    message: `➡️ Building right subtree for range [${rootInorderIndex + 1}, ${right}]`,
                    treeData: JSON.parse(JSON.stringify(allNodes)),
                    callStack: JSON.parse(JSON.stringify(callStack)),
                    codeStep: 5,
                    flowStep: 'right'
                });
                
                const rightChild = dfs(rootInorderIndex + 1, right, depth + 1);
                if (rightChild) {
                    node.right = rightChild.id;
                    steps.push({
                        preIndex,
                        inLeft: left,
                        inRight: right,
                        inMid: rootInorderIndex,
                        message: `✅ Connected ${rootVal}.right → ${rightChild.val}`,
                        treeData: JSON.parse(JSON.stringify(allNodes)),
                        callStack: JSON.parse(JSON.stringify(callStack)),
                        codeStep: 5,
                        flowStep: 'right'
                    });
                }
                
                // Remove from call stack before returning
                callStack.pop();
                steps.push({
                    preIndex,
                    inLeft: left,
                    inRight: right,
                    inMid: rootInorderIndex,
                    message: `🔙 Returning node ${rootVal} from buildTreeHelper(${left}, ${right})`,
                    treeData: JSON.parse(JSON.stringify(allNodes)),
                    callStack: JSON.parse(JSON.stringify(callStack)),
                    codeStep: 6,
                    flowStep: 'return'
                });
                
                return node;
            }
            
            dfs(0, inorderArray.length - 1);
            
            // Add final completion step
            steps.push({
                preIndex,
                inLeft: -1,
                inRight: -1,
                inMid: -1,
                message: `🎉 Binary Tree Construction Complete! Root: ${allNodes.length > 0 ? allNodes[0].val : 'None'}`,
                treeData: JSON.parse(JSON.stringify(allNodes)),
                callStack: [],
                codeStep: 6,
                flowStep: 'complete'
            });
            
            logWithType(`🎉 Generated ${steps.length} steps for visualization`, 'success');
            return steps;
        }
        
        function renderStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= steps.length) return;
            
            const step = steps[stepIndex];
            
            // Update array displays
            displayArrays(step.preIndex - 1, step.inLeft, step.inRight, step.inMid);
            
            // Update tree visualization
            drawTree(step.treeData);
            
            // Update call stack
            if (step.callStack) {
                updateCallStack(step.callStack);
            }
            
            // Update algorithm step
            if (step.codeStep) {
                displayCodeStep(step.codeStep);
            }
            
            // Update flowchart
            if (step.flowStep) {
                updateFlowchart(step.flowStep);
            }
            
            // Update algorithm states
            const stateStatus = document.getElementById('state-status');
            const statePreorderIndex = document.getElementById('state-preorder-index');
            const stateRange = document.getElementById('state-range');
            const stateRootValue = document.getElementById('state-root-value');
            const stateRootIndex = document.getElementById('state-root-index');
            
            if (stateStatus) stateStatus.textContent = step.callStack && step.callStack.length > 0 ? 'Processing' : 'Idle';
            if (statePreorderIndex) statePreorderIndex.textContent = step.preIndex >= 0 ? step.preIndex : 'N/A';
            if (stateRange) stateRange.textContent = step.inLeft >= 0 && step.inRight >= 0 ? `[${step.inLeft}, ${step.inRight}]` : 'N/A';
            if (stateRootValue) {
                if (step.preIndex > 0 && step.preIndex <= preorderArray.length) {
                    stateRootValue.textContent = preorderArray[step.preIndex - 1];
                } else {
                    stateRootValue.textContent = 'N/A';
                }
            }
            if (stateRootIndex) stateRootIndex.textContent = step.inMid >= 0 ? step.inMid : 'N/A';
            
            // Log the message with appropriate type
            if (step.message.includes('❌')) {
                logWithType(step.message, 'error');
            } else if (step.message.includes('✅') || step.message.includes('🎉')) {
                logWithType(step.message, 'success');
            } else if (step.message.includes('⬅️') || step.message.includes('➡️') || step.message.includes('🔄')) {
                logWithType(step.message, 'warning');
            } else {
                logWithType(step.message, 'info');
            }
        }
        
        function runVisualization() {
            logContainer.innerHTML = '';
            log('Starting visualization...');
            
            // Parse input
            const preorderStr = preorderInput.value.trim();
            const inorderStr = inorderInput.value.trim();
            
            if (!preorderStr || !inorderStr) {
                alert('Please enter both preorder and inorder arrays');
                return;
            }
            
            try {
                preorderArray = preorderStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
                inorderArray = inorderStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
            } catch (e) {
                alert('Invalid input format. Please use comma-separated integers.');
                return;
            }
            
            if (preorderArray.length !== inorderArray.length || preorderArray.length === 0) {
                alert('Arrays must have the same length and contain at least one element');
                return;
            }
            
            // Validate that both arrays contain the same elements
            const preorderSet = new Set(preorderArray);
            const inorderSet = new Set(inorderArray);
            if (preorderSet.size !== inorderSet.size || 
                ![...preorderSet].every(val => inorderSet.has(val))) {
                alert('Arrays must contain the same elements');
                return;
            }
            
            log(`Preorder: [${preorderArray.join(', ')}]`);
            log(`Inorder: [${inorderArray.join(', ')}]`);
            
            // Build steps
            buildTree();
            
            // Reset and show first step
            currentStep = 0;
            renderStep(currentStep);
            
            logWithType(`✅ Visualization ready! Use the controls to step through the algorithm.`, 'success');
        }
        
        function stepForward() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                renderStep(currentStep);
            } else {
                stopAnimation();
            }
        }
        
        function stepBackward() {
            if (currentStep > 0) {
                currentStep--;
                renderStep(currentStep);
            }
        }
        
        function togglePlay() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }
        
        function startAnimation() {
            isPlaying = true;
            if (playIcon && pauseIcon) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
            playInterval = setInterval(stepForward, 1500);
        }
        
        function stopAnimation() {
            isPlaying = false;
            if (playIcon && pauseIcon) {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
            clearInterval(playInterval);
        }
        
        function resetVisualization() {
            stopAnimation();
            currentStep = 0;
            logContainer.innerHTML = '';
            if (steps.length > 0) {
                renderStep(currentStep);
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, adding event listeners');
            
            runBtn.addEventListener('click', runVisualization);
            stepBackBtn.addEventListener('click', stepBackward);
            playPauseBtn.addEventListener('click', togglePlay);
            stepForwardBtn.addEventListener('click', stepForward);
            resetBtn.addEventListener('click', resetVisualization);
            
            // Algorithm step navigation
            prevStepBtn.addEventListener('click', () => {
                if (currentCodeStep > 0) {
                    displayCodeStep(currentCodeStep - 1);
                }
            });
            
            nextStepBtn.addEventListener('click', () => {
                if (currentCodeStep < algorithmSteps.length - 1) {
                    displayCodeStep(currentCodeStep + 1);
                }
            });
            
            // Initialize display
            displayCodeStep(0);
            updateCallStack([]);
            updateFlowchart('start');
            
            // Welcome message
            logWithType('🚀 Welcome! Enter preorder and inorder arrays, then click "Run Visualization" to see the algorithm in action.', 'info');
        });
        
        console.log('Script setup complete');
    </script>
</body>
</html>
